---
tags:
  - GenAI
aliases:
cssclasses:
created: 2025-07-19 17:34:48 +09:00
updated: 2025-07-19 17:34:48 +09:00
---
# 마틴 파울러의 리팩토링: 개발 에이전트를 위한 심층 가이드

## I. 서론: 리팩토링, 소프트웨어 공학의 연금술

소프트웨어 개발은 단순히 새로운 기능을 추가하는 행위의 연속이 아닙니다. 그것은 살아있는 유기체와 같은 코드베이스를 지속적으로 건강하게 유지하고 발전시키는 과정입니다. 이 과정의 핵심에 바로 **리팩토링(Refactoring)**이 있습니다.

마틴 파울러는 리팩토링을 다음과 같이 정의했습니다.

> **"소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드의 내부 구조를 변경하여 이해하기 쉽고 수정하기 용이하게 만드는 체계적인 기술"**

이 정의에는 리팩토링의 두 가지 핵심 속성이 담겨 있습니다.

1. **외부 행위의 불변성 (Behavior Preservation):** 리팩토링은 버그 수정이나 기능 추가가 아닙니다. 리팩토링 전후에 소프트웨어가 사용자나 다른 시스템에게 제공하는 기능은 완벽하게 동일해야 합니다. 이것이 리팩토링을 안전하게 만드는 대전제입니다.
    
2. **내부 구조의 개선 (Internal Structure Improvement):** 리팩토링의 목적은 코드의 가독성, 유지보수성, 확장성을 높이는 것입니다. 이를 통해 미래의 개발 속도를 저해하는 '기술 부채(Technical Debt)'를 상환하고, 코드베이스의 건강을 증진시킵니다.
    

### 왜 리팩토링은 필수적인가?

초기 스타트업이나 빠른 프로토타이핑 단계에서는 속도가 가장 중요해 보일 수 있습니다. 그러나 장기적인 관점에서 리팩토링 없는 개발은 필연적으로 다음과 같은 문제에 직면합니다.

- **소프트웨어 디자인의 부패:** 초기의 깔끔했던 설계는 계속되는 기능 추가와 수정 속에서 서서히 무너집니다. 코드는 복잡해지고, 모듈 간의 결합도는 높아지며, 응집도는 낮아집니다.
    
- **개발 속도의 저하:** 코드를 이해하는 데 걸리는 시간이 길어지고, 작은 변경 하나가 예상치 못한 수많은 버그를 유발합니다. 새로운 기능을 추가하는 비용이 기하급수적으로 증가하여 결국 개발이 정체됩니다.
    
- **버그 발생률 증가:** 복잡하고 얽힌 코드는 버그가 숨어들기 좋은 환경을 제공합니다. 버그를 찾아 수정하는 것 또한 매우 어려워집니다.
    
- **개발자 사기 저하:** 누구도 '스파게티 코드'나 '빅 볼 오브 머드(Big Ball of Mud)' 위에서 일하고 싶어 하지 않습니다. 나쁜 코드는 개발의 즐거움을 앗아가고 팀의 생산성을 떨어뜨립니다.
    

리팩토링은 이러한 문제들을 해결하는 가장 효과적인 처방전입니다. 그것은 단기적인 속도를 위해 쌓아둔 기술 부채에 대한 이자를 갚는 행위이며, 미래의 개발을 위한 튼튼한 발판을 마련하는 투자입니다.

## II. 리팩토링의 핵심 원칙

효과적이고 안전한 리팩토링을 위해서는 반드시 지켜야 할 몇 가지 원칙이 있습니다.

### 1. 두 개의 모자 (The Two Hats)

개발자는 항상 두 종류의 모자를 번갈아 써야 합니다. 하나는 **'기능 추가 모자'**이고, 다른 하나는 **'리팩토링 모자'**입니다.

- **기능 추가 모자:** 이 모자를 쓸 때는 오직 새로운 기능을 구현하거나 기존 기능의 버그를 잡는 데에만 집중합니다. 코드가 다소 지저분해지더라도 목표 달성을 우선시합니다. 이때는 기존 코드를 건드리지 않고, 새로운 테스트를 추가하고 통과시키는 데 집중합니다.
    
- **리팩토링 모자:** 이 모자를 쓸 때는 절대 새로운 기능을 추가하지 않습니다. 오직 코드의 구조를 개선하는 데에만 집중합니다. 기존의 모든 테스트가 변함없이 통과하는 것을 확인하며, 작고 안전한 단계로 코드를 변경합니다.
    

가장 위험한 행동은 이 두 가지 모자를 동시에 쓰는 것입니다. 기능 추가와 구조 개선을 한 번에 하려고 하면, 두 가지 목표 모두를 놓치고 복잡한 버그를 만들어낼 가능성이 높습니다. **"기능을 추가할 땐 구조를 신경 쓰지 말고, 리팩토링할 땐 기능을 신경 쓰지 말라."** 이것이 핵심입니다.

### 2. 작고 안전한 단계로 진행하라 (Refactor in Small, Safe Steps)

리팩토링은 대규모의 '코드 재작성(Rewrite)'이 아닙니다. 거대한 변화를 한 번에 시도하는 것은 매우 위험합니다. 대신, 검증된 리팩토링 기법들을 사용하여 작고, 기계적이며, 예측 가능한 단계들로 나누어 진행해야 합니다.

예를 들어, 긴 메서드를 여러 개의 작은 메서드로 나누는 '메서드 추출(Extract Method)'을 한다면, 한 번에 하나의 코드 블록만 추출하고, 즉시 컴파일하고, 테스트를 실행해야 합니다. 이 과정이 성공하면, 다음 단계를 진행합니다. 만약 문제가 발생하면, 마지막의 작은 변경 사항만 되돌리면 되므로 원인 파악과 복구가 매우 용이합니다.

### 3. 테스트는 당신의 안전망이다 (Tests are Your Safety Net)

리팩토링의 전제 조건은 '겉보기 동작을 바꾸지 않는다'는 것입니다. 이를 어떻게 보장할 수 있을까요? 바로 **자동화된 자가 테스트(Self-Testing Code)**입니다.

신뢰할 수 있는 테스트 스위트(Test Suite)가 없다면, 당신은 리팩토링을 하는 것이 아니라 그저 '코드를 바꾸고 있을 뿐'입니다. 테스트는 당신이 실수로 기존 기능을 망가뜨렸을 때 즉시 경고해주는 든든한 안전망입니다.

- 리팩토링을 시작하기 전에, 반드시 해당 코드 영역을 커버하는 테스트가 있는지 확인하고, 없다면 작성해야 합니다.
    
- 모든 테스트는 리팩토링 시작 전에 100% 통과해야 합니다.
    
- 리팩토링의 각 작은 단계를 마칠 때마다 전체 테스트를 실행하여 여전히 100% 통과하는지 확인해야 합니다.
    

### 4. 언제 리팩토링해야 하는가? (When to Refactor?)

- **삼진 법칙 (The Rule of Three):** 처음에는 그냥 코드를 작성합니다. 두 번째로 비슷한 작업을 하게 되면, 중복이 거슬리지만 일단 복사해서 붙여넣습니다. 하지만 세 번째로 같은 작업을 하게 되면, 더 이상 미루지 말고 즉시 리팩토링하여 중복을 제거하고 추상화를 도입해야 합니다.
    
- **준비형 리팩토링 (Preparatory Refactoring):** 새로운 기능을 추가하기 전에, 기존 코드를 약간 정리하면 새 기능을 훨씬 쉽게 추가할 수 있을 때가 있습니다. 이때 먼저 리팩토링을 해서 구조를 개선한 뒤, 새로운 기능 개발을 시작합니다.
    
- **이해를 위한 리팩토링 (Comprehension Refactoring):** 복잡하고 이해하기 어려운 코드를 수정해야 할 때, 먼저 코드를 이해하기 쉬운 구조로 리팩토링합니다. 변수 이름을 명확하게 바꾸고, 긴 메서드를 분리하는 등의 작업을 통해 코드의 의도를 파악하고 나면, 원래 하려던 수정 작업이 훨씬 쉬워집니다.
    
- **쓰레기 줍기 리팩토링 (Litter-Pickup Refactoring):** 코드를 읽다가 작은 문제점(나쁜 변수 이름, 불필요한 주석 등)을 발견하면, 즉시 수정합니다. 마치 길에 떨어진 쓰레기를 줍는 것처럼, 코드베이스를 항상 깨끗하게 유지하는 습관입니다.
    
- **계획된 리팩토링 (Planned Refactoring):** 대부분의 리팩토링은 일상적인 개발 과정에 녹아들어야 하지만, 때로는 팀 전체가 시간을 할애하여 심각한 기술 부채를 해결하기 위한 계획된 리팩토링 세션을 가질 필요도 있습니다.
    

## III. 코드 스멜: 리팩토링의 신호

'코드 스멜(Code Smell)'은 코드 자체는 버그가 아니지만, 더 깊은 곳에 구조적인 문제가 있음을 암시하는 '나쁜 냄새'입니다. 코드 스멜은 리팩토링이 필요한 지점을 알려주는 중요한 신호입니다.

### A. 비대해진 코드 (Bloaters)

코드의 크기가 비정상적으로 커져서 다루기 어려워진 경우입니다.

- **긴 메서드 (Long Method):** 하나의 메서드가 너무 많은 일을 하고 있습니다. 메서드가 수십, 수백 줄에 달하면 이해, 재사용, 테스트가 거의 불가능합니다.
    
    - **문제점:** 단일 책임 원칙(SRP) 위반, 낮은 응집도, 코드 중복 유발.
        
    - **해결책:** 메서드 추출(Extract Method), 임시 변수를 질의 함수로 바꾸기(Replace Temp with Query), 조건문 분해(Decompose Conditional), 다형성으로 조건문 대체(Replace Conditional with Polymorphism).
        
- **거대한 클래스 (Large Class):** 하나의 클래스가 너무 많은 필드와 메서드를 가지고 있습니다. 이는 클래스가 여러 책임을 동시에 수행하고 있음을 의미합니다.
    
    - **문제점:** 단일 책임 원칙(SRP) 위반, 낮은 응집도, 유지보수 비용 증가.
        
    - **해결책:** 클래스 추출(Extract Class), 서브클래스 추출(Extract Subclass), 인터페이스 추출(Extract Interface).
        
- **원시 타입 집착 (Primitive Obsession):** 전화번호, 우편번호, 돈(Money) 등 고유한 의미와 로직을 가져야 할 데이터를 단순한 문자열이나 숫자 같은 원시 타입으로만 다루는 경우입니다.
    
    - **문제점:** 관련 로직이 여러 곳에 흩어짐, 유효성 검사 누락, 코드의 의미 불분명.
        
    - **해결책:** 데이터 값을 객체로 바꾸기(Replace Data Value with Object), 타입 코드를 클래스로 바꾸기(Replace Type Code with Class).
        
- **긴 매개변수 목록 (Long Parameter List):** 메서드나 함수가 3~4개 이상의 매개변수를 받는 경우입니다.
    
    - **문제점:** 호출하기 어렵고, 일관성 유지가 힘들며, 불필요한 의존성 유발.
        
    - **해결책:** 매개변수 객체 만들기(Introduce Parameter Object), 객체 통째로 넘기기(Preserve Whole Object), 매개변수 제거(Remove Parameter).
        
- **데이터 덩어리 (Data Clumps):** 여러 곳에서 항상 함께 나타나는 데이터 그룹(예: 시작일, 종료일)입니다. 이들은 논리적으로 하나의 단위여야 함을 시사합니다.
    
    - **문제점:** 코드 중복, 한 필드를 수정할 때 다른 필드를 빠뜨릴 위험.
        
    - **해결책:** 클래스 추출(Extract Class)을 통해 데이터 덩어리를 하나의 객체로 묶습니다.
        

### B. 객체 지향 원칙 위반 (Object-Orientation Abusers)

객체 지향의 장점을 제대로 활용하지 못하거나 오용하는 경우입니다.

- **Switch 문 (Switch Statements):** 타입 코드나 특정 조건에 따라 분기하는 거대한 switch 문은 새로운 타입을 추가할 때마다 모든 switch 문을 찾아 수정해야 하는 문제를 야기합니다.
    
    - **문제점:** 개방-폐쇄 원칙(OCP) 위반, 코드 중복.
        
    - **해결책:** 다형성으로 조건문 대체(Replace Conditional with Polymorphism), 타입 코드를 서브클래스로 바꾸기(Replace Type Code with Subclasses).
        
- **임시 필드 (Temporary Field):** 특정 상황에서만 값이 설정되는 클래스 필드입니다. 코드를 이해하기 어렵게 만들고, 객체의 상태가 불분명해집니다.
    
    - **문제점:** 클래스의 책임이 불분명해짐, 코드 이해도 저하.
        
    - **해결책:** 클래스 추출(Extract Class)을 통해 임시 필드와 관련 로직을 별도의 클래스로 분리, Null 객체 도입(Introduce Null Object).
        
- **상속 포기 (Refused Bequest):** 서브클래스가 부모 클래스의 일부 메서드나 필드만을 필요로 하고 나머지는 사용하지 않는 경우입니다. 이는 상속 계층이 잘못되었음을 의미합니다.
    
    - **문제점:** 리스코프 치환 원칙(LSP) 위반 가능성, 불필요한 복잡성.
        
    - **해결책:** 상속을 위임으로 바꾸기(Replace Inheritance with Delegation), 서브클래스를 위임으로 바꾸기(Replace Subclass with Delegate).
        

### C. 변경을 방해하는 설계 (Change Preventers)

하나의 변경을 위해 여러 곳을 동시에 수정해야 하는 경직된 설계입니다.

- **산탄총 수술 (Shotgun Surgery):** 하나의 기능을 변경하기 위해 여러 클래스를 조금씩 수정해야 하는 상황입니다. 이는 책임이 여러 곳에 흩어져 있음을 의미합니다.
    
    - **문제점:** 변경 누락 위험, 높은 결합도.
        
    - **해결책:** 메서드 이동(Move Method), 필드 이동(Move Field)을 통해 관련 있는 코드들을 한 곳으로 모아 응집도를 높입니다. 인라인 클래스(Inline Class)도 고려할 수 있습니다.
        
- **뒤엉킨 변경 (Divergent Change):** 하나의 클래스가 서로 다른 이유로 자주 변경되는 경우입니다. 예를 들어, 데이터베이스 관련 로직과 비즈니스 로직이 한 클래스에 섞여 있으면, DB 스키마가 바뀔 때도, 비즈니스 규칙이 바뀔 때도 이 클래스를 수정해야 합니다.
    
    - **문제점:** 단일 책임 원칙(SRP) 위반, 낮은 응집도.
        
    - **해결책:** 클래스 추출(Extract Class)을 통해 서로 다른 변경의 이유를 가진 책임들을 별개의 클래스로 분리합니다.
        

### D. 불필요한 요소 (Dispensables)

존재 이유가 없거나 코드를 더럽히기만 하는 요소들입니다.

- **주석 (Comments):** 코드가 스스로를 설명하지 못할 때 주석을 달게 됩니다. "왜" 이렇게 작성했는지를 설명하는 주석은 유용할 수 있지만, "무엇을" 하는지를 설명하는 주석은 코드를 개선하여 불필요하게 만들어야 합니다.
    
    - **문제점:** 코드가 변경될 때 주석은 갱신되지 않아 거짓말을 하게 될 수 있음.
        
    - **해결책:** 메서드 추출(Extract Method), 변수 이름 바꾸기(Rename Variable) 등을 통해 코드가 의도를 명확히 드러내게 합니다.
        
- **중복 코드 (Duplicated Code):** 소프트웨어에서 가장 큰 악 중 하나입니다. 똑같거나 매우 유사한 코드가 여러 곳에 존재합니다.
    
    - **문제점:** 변경 시 모든 중복 지점을 찾아 수정해야 함, 버그 발생의 온상.
        
    - **해결책:** 메서드 추출(Extract Method), 상위 클래스로 메서드 올리기(Pull Up Method), 템플릿 메서드 패턴(Template Method Pattern) 적용.
        
- **게으른 클래스 (Lazy Class):** 별다른 역할을 하지 않아 그 존재 가치가 없는 클래스입니다.
    
    - **문제점:** 불필요한 복잡성 증가.
        
    - **해결책:** 클래스 인라인(Inline Class)을 통해 해당 클래스의 기능을 다른 클래스로 흡수시킵니다.
        
- **죽은 코드 (Dead Code):** 더 이상 호출되거나 사용되지 않는 변수, 매개변수, 메서드, 클래스입니다.
    
    - **문제점:** 코드베이스를 불필요하게 복잡하게 만듦.
        
    - **해결책:** 과감하게 삭제합니다. 버전 관리 시스템이 있으므로 걱정할 필요가 없습니다.
        

### E. 결합을 유발하는 요소 (Couplers)

클래스 간의 결합도를 지나치게 높여 시스템을 경직시키는 요소들입니다.

- **기능 편애 (Feature Envy):** 한 클래스의 메서드가 자기 자신의 데이터보다 다른 클래스의 데이터를 더 많이 사용하는 경우입니다. 마치 다른 클래스의 기능을 '부러워하는' 것처럼 보입니다.
    
    - **문제점:** 높은 결합도, 잘못된 책임 분배.
        
    - **해결책:** 메서드 이동(Move Method)을 통해 해당 메서드를 데이터가 있는 클래스로 옮깁니다.
        
- **메시지 체인 (Message Chains):** `a.getB().getC().doSomething()`과 같이 객체 탐색이 길게 이어지는 코드입니다. 이는 클라이언트가 시스템의 내부 구조에 깊숙이 의존하게 만듭니다.
    
    - **문제점:** 데메테르 법칙(Law of Demeter) 위반, 높은 결합도.
        
    - **해결책:** 대리 객체 숨기기(Hide Delegate)를 통해 중간 객체들이 요청을 위임하도록 만듭니다.
        

## IV. 핵심 리팩토링 기법

코드 스멜을 제거하는 데 사용되는 구체적인 기술들입니다. 모든 기법은 작고 안전한 단계를 따릅니다.

1. **메서드 추출 (Extract Method):** 가장 기본적이고 자주 사용되는 기법입니다. 긴 메서드 내의 코드 일부를 독립적인 새 메서드로 분리하고, 원래 위치에서는 새 메서드를 호출합니다.
    
2. **클래스 추출 (Extract Class):** 거대한 클래스의 일부 책임(데이터와 관련 메서드)을 새로운 클래스로 분리합니다.
    
3. **메서드 이동 / 필드 이동 (Move Method / Move Field):** 특정 메서드나 필드가 자신이 속한 클래스보다 다른 클래스와 더 많이 상호작용할 때, 해당 요소들을 더 적절한 클래스로 옮깁니다.
    
4. **다형성으로 조건문 대체 (Replace Conditional with Polymorphism):** 객체의 타입에 따라 행동을 달리하는 switch 문이나 if-else 문을 다형성을 이용해 제거합니다. 각 타입별로 서브클래스를 만들고, 분기 로직을 각 서브클래스의 메서드 재정의(override)로 대체합니다.
    
5. **메서드 이름 바꾸기 / 변수 이름 바꾸기 (Rename Method / Rename Variable):** 이름이 코드의 의도를 명확하게 드러내지 못할 때, 더 나은 이름으로 변경합니다.
    
6. **상속을 위임으로 바꾸기 (Replace Inheritance with Delegation):** 상속이 적절하지 않은 경우(is-a 관계가 아닐 때), 상속 관계를 끊고 필드를 통해 다른 클래스의 객체를 참조하여 필요한 기능을 위임(delegate)하는 방식으로 변경합니다.
    
7. **매개변수 객체 만들기 (Introduce Parameter Object):** 항상 함께 움직이는 데이터 덩어리(Data Clumps)를 매개변수로 받을 때, 이 데이터들을 하나의 클래스(Parameter Object)로 묶어 전달합니다.
    

## V. 성공적인 리팩토링을 위한 문화와 전략

리팩토링은 한두 명의 뛰어난 개발자가 아니라 팀 전체의 문화로 자리 잡아야 합니다.

- **개발 워크플로우에 통합:** 리팩토링을 별도의 작업으로 취급하지 말고, 기능 개발과 버그 수정 등 모든 개발 활동의 일부로 만들어야 합니다. '두 개의 모자' 원칙을 항상 기억하고 실천합니다.
    
- **코드 리뷰와 짝 프로그래밍:** 동료의 코드를 리뷰하거나 함께 코드를 작성하면서 코드 스멜을 발견하고 개선 방안을 논의하는 것은 리팩토링 문화를 확산시키는 가장 좋은 방법입니다. 지식을 공유하고 코드 품질에 대한 공동의 책임감을 형성합니다.
    
- **경영진의 지원과 기술 부채 관리:** 리팩토링은 당장 눈에 보이는 성과를 내지 않기 때문에 경영진이나 비개발 직군의 이해를 얻기 어려울 수 있습니다. 기술 부채의 위험성과 리팩토링의 장기적인 이점을 지속적으로 설득하고, 개발 시간의 일부(예: 10~20%)를 코드 개선에 할애할 수 있도록 합의를 이끌어내야 합니다.
    
- **도구의 적극적인 활용:** 최신 IDE(통합 개발 환경)는 대부분의 기본적인 리팩토링 기법(메서드 추출, 이름 바꾸기 등)을 자동화된 방식으로 안전하게 지원합니다. 정적 분석 도구를 도입하여 코드 스멜을 자동으로 찾아내는 것도 좋은 방법입니다.
    

## VI. 결론: 진화하는 코드베이스를 향하여

소프트웨어는 한번 만들어지고 끝나는 조각상이 아니라, 끊임없이 변화하고 성장하는 정원과 같습니다. 리팩토링은 이 정원을 가꾸는 정원사의 활동입니다. 잡초(코드 스멜)를 뽑고, 가지(구조)를 치고, 토양(설계)에 영양분을 공급하여 나무(소프트웨어)가 더 크고 건강하게 자라도록 돕는 것입니다.

리팩토링은 추가적인 작업이 아니라, 프로페셔널 소프트웨어 개발자의 핵심 역량이자 책임입니다. 깨끗하고, 이해하기 쉬우며, 변경에 유연한 코드를 작성하는 것은 우리 자신과 미래의 동료들을 위한 가장 중요한 투자입니다. 이 가이드가 개발 에이전트의 코드 생성 및 수정 활동에 깊이 내재화되어, 모든 결과물이 지속적으로 개선되고 진화하는 고품질 코드베이스를 구축하는 데 기여하기를 바랍니다.
