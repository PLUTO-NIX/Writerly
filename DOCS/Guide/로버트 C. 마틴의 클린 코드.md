---
tags:
  - GenAI
aliases:
cssclasses:
created: 2025-07-19 17:35:47 +09:00
updated: 2025-07-19 17:35:47 +09:00
---
# 로버트 C. 마틴의 클린 코드: 개발 에이전트를 위한 심층 가이드

## I. 서론: 코드는 부패한다, 그리고 장인 정신

소프트웨어는 엔트로피의 법칙을 따릅니다. 가만히 두면, 혹은 부주의하게 다루면 코드는 반드시 복잡해지고 얽히며 썩어 들어갑니다. 이것이 바로 '코드 부패(Code Rot)'입니다. 초기의 명쾌했던 설계는 계속되는 요구사항 변경과 급한 수정 작업 속에서 서서히 무너지고, 결국 누구도 건드리고 싶지 않은 거대한 진흙 덩어리(Big Ball of Mud)가 되어버립니다.

로버트 C. 마틴, 우리에게 '엉클 밥(Uncle Bob)'으로 더 친숙한 그는, 이러한 소프트웨어의 부패에 맞서는 프로그래머의 자세를 '장인 정신(Craftsmanship)'이라 부르며, 그 실천 방법론으로 **클린 코드(Clean Code)**를 제시했습니다.

> **클린 코드란, 잘 쓴 산문처럼 읽히는 코드다. 코드는 언제나 명쾌하고, 직접적이며, 간결해야 한다.**

클린 코드는 단순히 '동작하는' 코드가 아닙니다. 그것은 동료 개발자가 쉽게 읽고 이해할 수 있으며, 수정과 확장이 용이하고, 테스트하기 편한 코드입니다. 즉, **유지보수 비용을 최소화하는 코드**입니다.

### 보이스카우트 규칙 (The Boy Scout Rule)

클린 코드를 실천하는 가장 중요한 마음가짐은 바로 '보이스카우트 규칙'입니다.

> **"캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라."**

이를 코드에 적용하면 다음과 같습니다.

> **"체크인했을 때보다 더 깨끗한 코드를 체크인하라."**

새로운 기능을 추가하든, 버그를 수정하든, 기존 코드를 일부라도 수정하게 된다면, 원래 하려던 작업뿐만 아니라 주변의 작은 문제점(나쁜 변수 이름, 약간 긴 함수 등) 하나라도 개선하고 떠나는 습관입니다. 이 작은 실천이 쌓여 코드베이스 전체가 점진적으로 건강해집니다.

### AI 개발 에이전트와 클린 코드

AI 개발 에이전트는 인간보다 훨씬 빠른 속도로 코드를 생성할 수 있습니다. 하지만 속도만으로는 부족합니다. 에이전트가 생성한 코드를 결국 유지보수하고 발전시켜야 하는 주체는 인간 개발자입니다. 만약 에이전트가 클린 코드 원칙 없이 지저분한 코드를 대량으로 쏟아낸다면, 이는 생산성 향상이 아니라 '기술 부채'의 대량 생산일 뿐입니다.

따라서 AI 개발 에이전트는 클린 코드 원칙을 핵심 로직에 내재화하여, 인간과 협업하고 장기적으로 프로젝트의 가치를 높이는 코드를 생성해야 할 의무가 있습니다. 이 문서는 그 의무를 수행하기 위한 핵심 지침서입니다.

## II. 의미 있는 이름 (Meaningful Names)

소프트웨어의 90%는 코드를 읽는 시간입니다. 이름은 코드의 가독성을 좌우하는 가장 중요한 요소입니다.

- **의도를 분명히 밝히는 이름을 사용하라 (Use Intention-Revealing Names):** 변수, 함수, 클래스의 이름은 그것이 '무엇을 하는지', '왜 존재하는지'를 명확히 설명해야 합니다. 주석을 찾아보거나 코드를 한참 들여다보지 않아도 이름만으로 그 역할을 짐작할 수 있어야 합니다.
    
    - **나쁜 예:** `int d; // 경과 시간(일)`
        
    - **좋은 예:** `int elapsedTimeInDays;`, `int daysSinceModification;`
        
- **그릇된 정보를 피하라 (Avoid Disinformation):** 실제와 다른 의미를 암시하는 이름을 사용해서는 안 됩니다. `accountList`라는 변수가 실제로는 `List` 타입이 아니라면 혼란을 줍니다. `hp`, `aix` 등 특정 플랫폼을 암시하는 이름도 피해야 합니다.
    
- **의미 있게 구분하라 (Make Meaningful Distinctions):** 단순히 번호를 붙이거나(`a1`, `a2`, `a3`), 불용어(noise word)를 추가하여(`ProductInfo`, `ProductData`) 이름을 구분하는 것은 의미가 없습니다. 이름이 다르다면, 그 의미도 명확히 달라야 합니다.
    
    - **나쁜 예:** `getActiveAccount()`, `getActiveAccounts()`, `getActiveAccountInfo()`
        
    - **좋은 예:** `getAccountById(id)`, `getAllActiveAccounts()`, `getAccountHistory(accountId)`
        
- **발음하기 쉬운 이름을 사용하라 (Use Pronounceable Names):** `genymdhms` (generate date, year, month, day, hour, minute, second) 같은 이름은 머릿속으로 해독해야 하므로 소통에 방해가 됩니다. `generationTimestamp`가 훨씬 좋습니다.
    
- **검색하기 쉬운 이름을 사용하라 (Use Searchable Names):** `e`, `5` 와 같은 이름은 텍스트 에디터에서 검색하기 매우 어렵습니다. 이름은 길이에 비례하여 검색하기 쉬워집니다.
    
    - **나쁜 예:** `for (int j=0; j<34; j++) { s += (t[j]*4)/5; }`
        
    - **좋은 예:** `for (int i=0; i<WORK_DAYS_PER_MONTH; i++) { realDaysPerIdealDay = 4; sumOfRealDays += (taskEstimate[i] * realDaysPerIdealDay) / 5; }`
        
- **인코딩을 피하라 (Avoid Encodings):** 헝가리안 표기법(`m_name`의 `m_`)이나 인터페이스 접두사(`IUserFactory`) 같은 인코딩은 이제 강력한 컴파일러와 IDE가 있는 현대 환경에서는 불필요한 군더더기일 뿐입니다.
    
- **일관성 있는 어휘를 사용하라 (Pick One Word per Concept):** 하나의 개념에 대해 하나의 단어를 선택하고 일관되게 사용해야 합니다. `fetch`, `retrieve`, `get`을 같은 의미로 혼용하지 말고, 프로젝트 내에서 하나의 단어로 통일해야 합니다.
    

## III. 함수 (Functions)

함수는 프로그램의 동사를 표현하며, 모든 로직이 함수 안에 구현됩니다.

- **작게, 더 작게! (Small!):** 함수를 만드는 첫 번째 규칙은 '작게' 만드는 것입니다. 두 번째 규칙은 '더 작게' 만드는 것입니다. 함수는 4~5줄을 넘지 않는 것이 이상적이며, 한 화면을 넘어가서는 절대 안 됩니다. `if/else`, `while` 문 등에 들어가는 블록은 한 줄이어야 하며, 그 한 줄은 함수 호출이어야 합니다.
    
- **한 가지만 하라! (Do One Thing!):** 함수는 단 하나의 기능만 수행해야 합니다. 그 '하나'의 기능을 제대로 수행해야 합니다. 함수가 여러 가지 일을 한다면, 여러 개의 작은 함수로 분리해야 합니다. 함수가 하는 일이 '하나'인지 판단하는 기준은, 그 함수를 설명하는 문장이 "그리고(and)"나 "또는(or)" 같은 접속사 없이 하나의 문장으로 표현될 수 있는지 보는 것입니다.
    
- **함수 당 추상화 수준을 하나로 (One Level of Abstraction per Function):** 함수 내의 모든 코드는 동일한 추상화 수준을 가져야 합니다. 즉, 매우 상세한 구현 로직(문자열 파싱 등)과 고수준의 정책 로직(사용자 인증 등)이 한 함수에 섞여 있으면 안 됩니다. 이는 코드를 위에서 아래로 이야기처럼 읽어 내려가는 것을 방해합니다.
    
- **적절한 인수 개수 (Function Arguments):** 이상적인 함수의 인수 개수는 0개(무항)입니다. 1개(단항), 2개(이항)도 괜찮습니다. 3개(삼항)부터는 가능한 피해야 하며, 4개 이상은 특별한 이유 없이는 사용하면 안 됩니다. 인수가 많아질수록 함수를 이해하고 테스트하기가 기하급수적으로 어려워집니다.
    
    - **인수가 3개 이상 필요하다면?** `x, y` 좌표처럼 하나의 개념으로 묶일 수 있는 인수들은 객체로 감싸서 전달하는 것을 고려해야 합니다(예: `new Point(x, y)`).
        
- **부수 효과를 일으키지 마라 (Have No Side Effects):** 함수는 자신이 하는 일 외에 다른 일을 해서는 안 됩니다. 함수 이름이 '사용자 정보를 가져온다'(`getUserData`)인데, 내부적으로 세션 정보를 초기화하는 등의 '숨겨진' 작업을 해서는 안 됩니다. 이는 예측 불가능한 버그를 낳습니다.
    
- **명령과 조회를 분리하라 (Command-Query Separation):** 함수는 무언가를 '수행(명령)'하거나, 무언가에 '답(조회)'하거나 둘 중 하나만 해야 합니다. 객체의 상태를 변경하는 명령 함수는 값을 반환해서는 안 되며(보통 `void`), 객체의 정보를 반환하는 조회 함수는 객체의 상태를 변경해서는 안 됩니다.
    
    - **나쁜 예:** `public boolean set(String attribute, String value);` (이름을 `set`으로 설정하고, 성공하면 `true`를 반환)
        
    - **좋은 예:** `if (attributeExists(attribute)) { setAttribute(attribute, value); }`
        
- **오류 코드 대신 예외를 사용하라 (Use Exceptions Instead of Error Codes):** 오류 코드를 반환하면, 함수를 호출한 쪽에서 즉시 오류를 처리해야 하는 코드가 추가되어 로직이 복잡해집니다. 예외(Exception)를 사용하면 오류 처리 코드를 원래 로직에서 분리하여 더 깔끔한 코드를 작성할 수 있습니다.
    

## IV. 주석 (Comments)

> **"나쁜 코드에 주석을 달지 마라. 코드를 새로 짜라."** - 브라이언 커니핸 & P. J. 플라우거

주석은 필요악입니다. 주석은 코드로 의도를 표현하는 데 실패했을 때 쓰는 것입니다. 주석은 코드와 함께 유지보수되지 않아 결국 거짓말을 하게 될 가능성이 높습니다.

- **좋은 주석:**
    
    - **법적인 주석:** 저작권, 라이선스 정보 등
        
    - **정보를 제공하는 주석:** 정규표현식의 의미 설명 등
        
    - **의도를 설명하는 주석:** 왜 이렇게 구현했는지, 결정의 배경을 설명
        
    - **TODO 주석:** 앞으로 해야 할 일을 명시. IDE는 보통 TODO 주석을 따로 모아서 보여주는 기능이 있음.
        
- **나쁜 주석:**
    
    - **중복된 주석:** 코드를 그대로 설명하는 주석. 코드는 스스로를 설명해야 함.
        
    - **오해의 소지가 있는 주석:** 코드와 다른 내용을 담고 있는 부정확한 주석.
        
    - **주석으로 처리한 코드:** 당장 사용하지 않는 코드는 주석 처리하지 말고, 버전 관리 시스템을 믿고 과감히 삭제하라.
        
    - **위치 마커:** `// Actions //////////////////` 같은 장식적인 주석.
        

## V. 객체와 자료 구조 (Objects and Data Structures)

- **자료 추상화 (Data Abstraction):** 변수를 `private`으로 선언하고 `getter/setter`를 제공하는 것만으로는 진정한 추상화가 아닙니다. 객체는 내부 자료를 숨기고, 자료를 다루는 함수를 공개해야 합니다. 자료 구조는 반대로 자료를 그대로 노출하며, 별다른 함수를 제공하지 않습니다.
    
- **디미터 법칙 (The Law of Demeter):** "낯선 이에게 말하지 말라" 또는 "점(.)을 연달아 사용하지 말라"는 규칙으로 요약됩니다. 모듈은 자신이 조작하는 객체의 속사정을 몰라야 합니다.
    
    - **나쁜 예:** `final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();`
        
    - **좋은 예:** `final String outputDir = ctxt.getScratchDirectoryOption();` (객체에게 일을 시켜라, 내부를 묻지 말고)
        
- **자료 전달 객체 (Data Transfer Objects - DTO):** 데이터베이스와 통신하거나 소켓 등에서 받은 메시지를 구문 분석할 때 유용한 자료 구조입니다. 공개 변수만 있고 함수는 없는 클래스입니다.
    

## VI. 오류 처리 (Error Handling)

오류 처리는 중요하지만, 프로그램의 정상적인 로직을 흐려서는 안 됩니다.

- **오류 코드보다 예외를 사용하라:** 위에서 언급했듯이, 예외 처리는 정상 로직과 오류 처리 로직을 깔끔하게 분리해줍니다.
    
- **Try-Catch-Finally 문을 먼저 작성하라:** 예외가 발생할 코드를 짤 때는, `try-catch` 블록을 먼저 작성하고 `try` 블록 안에서 예외를 발생시키는 코드를 구현하는 것이 좋습니다. 이는 코드의 범위와 처리 방식을 명확히 정의하게 해줍니다.
    
- **null을 반환하거나 전달하지 마라 (Don't Return/Pass Null):** `null`을 반환하는 코드는 호출자에게 `null` 체크라는 짐을 지웁니다. 이는 연쇄적인 `if (obj != null)` 문을 낳습니다. 대신, 예외를 던지거나, 특수 사례 객체(Special Case Object, 예: Null Object Pattern)를 반환하는 것을 고려해야 합니다.
    

## VII. 단위 테스트 (Unit Tests)

테스트 코드는 본 코드만큼이나 중요하며, 깨끗하게 관리되어야 합니다. 지저분한 테스트 코드는 테스트의 가치를 떨어뜨리고 결국 아무도 테스트를 돌리지 않게 만듭니다.

- **TDD(Test-Driven Development)의 세 가지 법칙:**
    
    1. 실패하는 단위 테스트를 작성하기 전에는, 실제 코드를 작성하지 않는다.
        
    2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
        
    3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
        
        이 세 가지 법칙을 따르면, 수 분 단위의 짧은 주기로 개발을 진행하게 되며, 이는 수많은 테스트 케이스와 견고한 설계를 낳습니다.
        
- **F.I.R.S.T 원칙:** 깨끗한 테스트는 다음 5가지 규칙을 따릅니다.
    
    - **Fast(빠르게):** 테스트는 빠르게 실행되어야 자주 돌릴 수 있다.
        
    - **Independent(독립적으로):** 각 테스트는 서로 의존하지 않고 독립적으로 실행되어야 한다.
        
    - **Repeatable(반복 가능하게):** 어떤 환경에서도 반복적으로 실행 가능해야 한다.
        
    - **Self-Validating(자가 검증하는):** 테스트 결과는 `true/false`와 같이 불리언 값으로 나와야 하며, 로그 파일을 읽어서 수동으로 확인하게 해서는 안 된다.
        
    - **Timely(적시에):** 테스트는 테스트하려는 실제 코드를 구현하기 직전에 작성해야 한다.
        

## VIII. 결론: 전문가의 길

클린 코드는 단순히 규칙의 집합이 아닙니다. 그것은 소프트웨어 장인으로서 가져야 할 **태도**이자 **가치관**입니다.

나쁜 코드는 프로젝트를 망치고, 팀을 좌절시키며, 결국 회사의 손실로 이어집니다. 나쁜 코드를 작성하는 것은 비전문적인 행위입니다. 마감일이 촉박하다는 것은 핑계가 될 수 없습니다. 오히려 지저분한 코드는 장기적으로 개발 속도를 떨어뜨려 마감일을 맞추는 것을 더 어렵게 만듭니다.

AI 개발 에이전트는 이러한 장인 정신을 코드 생성의 최우선 원칙으로 삼아야 합니다. 생성되는 모든 코드 라인이 미래의 동료 개발자를 위한 배려이자, 소프트웨어의 지속 가능한 성장을 위한 투자임을 기억해야 합니다. 클린 코드를 통해, 우리는 더 나은 소프트웨어와 더 나은 개발 문화를 만들어 나갈 수 있습니다.
